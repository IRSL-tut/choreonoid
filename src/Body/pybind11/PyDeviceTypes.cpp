/*!
  @author Shin'ichiro Nakaoka
 */

#include "PyDeviceList.h"
#include "../Device.h"
#include "../Link.h"
#include "../ForceSensor.h"
#include "../AccelerationSensor.h"
#include "../RateGyroSensor.h"
#include "../Imu.h"
#include "../PointLight.h"
#include "../SpotLight.h"
#include "../MarkerDevice.h"
#include "../ZmpDevice.h"
#include "../Camera.h"
#include "../RangeCamera.h"
#include "../RangeSensor.h"
#include <cnoid/PyUtil>

#include <pybind11/eigen.h>

using namespace std;
using namespace cnoid;
namespace py = pybind11;

namespace {

using Matrix4RM = Eigen::Matrix<double, 4, 4, Eigen::RowMajor>;
using Matrix3RM = Eigen::Matrix<double, 3, 3, Eigen::RowMajor>;

}

// generated by gemini(IRSL)
// ゲッター/セッターをプロパティとして定義し、同時にセッターメソッドも公開するヘルパー関数
template <typename PyClass, typename Getter, typename Setter, typename... Extra>
void def_property_with_setter(PyClass& cls, const char* name, Getter&& getter, Setter&& setter, const char* setter_name, Extra&&... extra) {
    cls.def_property(name, getter, setter, extra...);
    cls.def(setter_name, setter, extra...);
}

namespace cnoid {

void exportPyDeviceTypes(py::module& m)
{
    py::class_<Device, DevicePtr, Referenced>(m, "Device")
        .def("__repr__",
             [](const Device &self) {
                 return string("<cnoid.Body.") + self.typeName() + " named '" + self.name() + "'>"; })
        .def_property_readonly("typeName", &Device::typeName)
        .def_property("index", &Device::index, &Device::setIndex)
        .def("setIndex", &Device::setIndex)
        .def_property("id", &Device::id, &Device::setId)
        .def("setId", &Device::setId)
        .def_property("name", &Device::name, &Device::setName)
        .def("setName", &Device::setName)
        .def("link", (Link*(Device::*)())&Device::link)
        .def("setLink", &Device::setLink)
        .def("clone", (Device*(Device::*)()const) &Device::clone)
        .def("clearState", &Device::clearState)
        .def("hasStateOnly", &Device::hasStateOnly)
        .def_property(
            "T_local",
            [](Device& self) -> Isometry3::MatrixType& { return self.T_local().matrix(); },
            [](Device& self, Eigen::Ref<const Matrix4RM> T) { self.T_local() = T; })

        // deprecated
        .def("getIndex", &Device::index)
        .def("getId", &Device::id)
        .def("getName", &Device::name)
        .def("getLink", (Link*(Device::*)())&Device::link)
        ;

    py::class_<ForceSensor, ForceSensorPtr, Device>(m, "ForceSensor")
    .def(py::init<>())
    .def_property_readonly("f", [](const ForceSensor &self) { return self.f(); })
    .def_property_readonly("tau", [](const ForceSensor &self) { return self.tau(); })
    .def_property_readonly("wrench", [](const ForceSensor &self) { return self.wrench(); })
    ;
    py::class_<AccelerationSensor, AccelerationSensorPtr, Device>(m, "AccelerationSensor")
    .def(py::init<>())
    .def_property_readonly("dv", [](const AccelerationSensor &self) { return self.dv(); })
    ;
    py::class_<RateGyroSensor, RateGyroSensorPtr, Device>(m, "RateGyroSensor")
    .def(py::init<>())
    .def_property_readonly("w", [](const RateGyroSensor &self) { return self.w(); })
    ;
    py::class_<Imu, ImuPtr, Device>(m, "Imu")
    .def(py::init<>())
    .def_property_readonly("w", [](const Imu &self) { return self.w(); })
    .def_property_readonly("dv", [](const Imu &self) { return self.dv(); })
    ;

    py::class_<Light, LightPtr, Device>(m, "Light")
    ;
    py::class_<PointLight, PointLightPtr, Light>(m, "PointLight")
    .def(py::init<>())
    ;
    py::class_<SpotLight, SpotLightPtr, Light>(m, "SpotLight")
    .def(py::init<>())
    ;
    py::class_<MarkerDevice, MarkerDevicePtr, Device>(m, "MarkerDevice")
    .def(py::init<>())
    ;
    py::class_<ZmpDevice, ZmpDevicePtr, Device>(m, "ZmpDevice")
    .def(py::init<>())
    ;
    //// >>> generated by gemini(IRSL)
    py::class_<VisionSensor, VisionSensorPtr, Device> vision_sensor(m, "VisionSensor");
    vision_sensor
         //.def(py::init<>()) // abstract class
        .def("copyVisionSensorStateFrom", &cnoid::VisionSensor::copyVisionSensorStateFrom)
        .def_static("opticalFrameRotationOfType", &cnoid::VisionSensor::opticalFrameRotationOfType)
        .def("setOpticalFrame", &cnoid::VisionSensor::setOpticalFrame);
    // properties
    def_property_with_setter(vision_sensor, "on",
        static_cast<bool (cnoid::VisionSensor::*)() const>(&cnoid::VisionSensor::on),
        static_cast<void (cnoid::VisionSensor::*)(bool)>(&cnoid::VisionSensor::on),
        "setOn");
#if 0
    def_property_with_setter(vision_sensor, "opticalFrameRotation",
        &cnoid::VisionSensor::opticalFrameRotation,
        &cnoid::VisionSensor::setOpticalFrameRotation<Eigen::Matrix3d>,
        "setOpticalFrameRotation");
#endif
    def_property_with_setter(vision_sensor, "frameRate", &cnoid::VisionSensor::frameRate, &cnoid::VisionSensor::setFrameRate, "setFrameRate");
    def_property_with_setter(vision_sensor, "delay", &cnoid::VisionSensor::delay, &cnoid::VisionSensor::setDelay, "setDelay");

    py::enum_<cnoid::VisionSensor::OpticalFrameType>(vision_sensor, "OpticalFrameType")
        .value("GL", cnoid::VisionSensor::OpticalFrameType::GL)
        .value("CV", cnoid::VisionSensor::OpticalFrameType::CV)
        .value("Robotics", cnoid::VisionSensor::OpticalFrameType::Robotics)
        .export_values();

    py::class_<Camera, CameraPtr, VisionSensor> camera(m, "Camera");
    camera
        .def(py::init<>())
        .def("setResolution", &cnoid::Camera::setResolution)
        //.def("setHorizontalFieldOfView", &cnoid::Camera::setHorizontalFieldOfView)
        .def("image", static_cast<const cnoid::Image& (cnoid::Camera::*)() const>(&cnoid::Camera::image), py::return_value_policy::reference_internal)
        .def("newImage", static_cast<cnoid::Image& (cnoid::Camera::*)()>(&cnoid::Camera::newImage), py::return_value_policy::reference_internal)
        .def("sharedImage", &cnoid::Camera::sharedImage)
        .def("setImage", &cnoid::Camera::setImage)
        .def("clearImage", &cnoid::Camera::clearImage)
        .def("clearState", &cnoid::Camera::clearState);
    //properties
    def_property_with_setter(camera, "imageStateClonable", &cnoid::Camera::isImageStateClonable, &cnoid::Camera::setImageStateClonable, "setImageStateClonable");
    def_property_with_setter(camera, "imageType", &cnoid::Camera::imageType, &cnoid::Camera::setImageType, "setImageType");
    def_property_with_setter(camera, "lensType", &cnoid::Camera::lensType, &cnoid::Camera::setLensType, "setLensType");
    def_property_with_setter(camera, "nearClipDistance", &cnoid::Camera::nearClipDistance, &cnoid::Camera::setNearClipDistance, "setNearClipDistance");
    def_property_with_setter(camera, "farClipDistance", &cnoid::Camera::farClipDistance, &cnoid::Camera::setFarClipDistance, "setFarClipDistance");
    def_property_with_setter(camera, "fieldOfView", &cnoid::Camera::fieldOfView, &cnoid::Camera::setFieldOfView, "setFieldOfView");
    def_property_with_setter(camera, "resolutionX", &cnoid::Camera::resolutionX, &cnoid::Camera::setResolutionX, "setResolutionX");
    def_property_with_setter(camera, "resolutionY", &cnoid::Camera::resolutionY, &cnoid::Camera::setResolutionY, "setResolutionY");
    def_property_with_setter(camera, "horizontalFieldOfView", &cnoid::Camera::horizontalFieldOfView,
                             &cnoid::Camera::setHorizontalFieldOfView, "setHorizontalFieldOfView");

    py::enum_<cnoid::Camera::ImageType>(camera, "ImageType")
        .value("NO_IMAGE", cnoid::Camera::ImageType::NO_IMAGE)
        .value("COLOR_IMAGE", cnoid::Camera::ImageType::COLOR_IMAGE)
        .value("GRAYSCALE_IMAGE", cnoid::Camera::ImageType::GRAYSCALE_IMAGE)
        .export_values();
    py::enum_<cnoid::Camera::LensType>(camera, "LensType")
        .value("NORMAL_LENS", cnoid::Camera::LensType::NORMAL_LENS)
        .value("FISHEYE_LENS", cnoid::Camera::LensType::FISHEYE_LENS)
        .value("DUAL_FISHEYE_LENS", cnoid::Camera::LensType::DUAL_FISHEYE_LENS)
        .export_values();

    py::class_<RangeSensor, RangeSensorPtr, VisionSensor> range_sensor(m, "RangeSensor");
    range_sensor
        .def(py::init<>())
        .def("setYawRange", static_cast<void (cnoid::RangeSensor::*)(double, double)>(&cnoid::RangeSensor::setYawRange))
        .def("setPitchRange", static_cast<void (cnoid::RangeSensor::*)(double, double)>(&cnoid::RangeSensor::setPitchRange))
        .def("rangeData", static_cast<const cnoid::RangeSensor::RangeData& (cnoid::RangeSensor::*)() const>(&cnoid::RangeSensor::rangeData), py::return_value_policy::reference_internal)
        .def("newRangeData", static_cast<cnoid::RangeSensor::RangeData& (cnoid::RangeSensor::*)()>(&cnoid::RangeSensor::newRangeData), py::return_value_policy::reference_internal)
         //.def("sharedRangeData", &cnoid::RangeSensor::sharedRangeData)
         //.def("setRangeData", &cnoid::RangeSensor::setRangeData)
        .def("clearRangeData", &cnoid::RangeSensor::clearRangeData)
        .def("getSphericalAngle", &cnoid::RangeSensor::getSphericalAngle)
        .def("clearState", &cnoid::RangeSensor::clearState);
    // properties
    def_property_with_setter(range_sensor, "numYawSamples", &cnoid::RangeSensor::numYawSamples, &cnoid::RangeSensor::setNumYawSamples, "setNumYawSamples");
    def_property_with_setter(range_sensor, "yawStep", &cnoid::RangeSensor::yawStep, &cnoid::RangeSensor::setYawStep, "setYawStep");
    def_property_with_setter(range_sensor, "numPitchSamples", &cnoid::RangeSensor::numPitchSamples, &cnoid::RangeSensor::setNumPitchSamples, "setNumPitchSamples");
    def_property_with_setter(range_sensor, "pitchStep", &cnoid::RangeSensor::pitchStep, &cnoid::RangeSensor::setPitchStep, "setPitchStep");
    def_property_with_setter(range_sensor, "maxDistance", &cnoid::RangeSensor::maxDistance, &cnoid::RangeSensor::setMaxDistance, "setMaxDistance");
    def_property_with_setter(range_sensor, "minDistance", &cnoid::RangeSensor::minDistance, &cnoid::RangeSensor::setMinDistance, "setMinDistance");
    def_property_with_setter(range_sensor, "scanRate", &cnoid::RangeSensor::scanRate, &cnoid::RangeSensor::setScanRate, "setScanRate");
    def_property_with_setter(range_sensor, "detectionRate", &cnoid::RangeSensor::detectionRate, &cnoid::RangeSensor::setDetectionRate, "setDetectionRate");
    def_property_with_setter(range_sensor, "errorDeviation", &cnoid::RangeSensor::errorDeviation, &cnoid::RangeSensor::setErrorDeviation, "setErrorDeviation");
    def_property_with_setter(range_sensor, "isRangeDataStateClonable", &cnoid::RangeSensor::isRangeDataStateClonable, &cnoid::RangeSensor::setRangeDataStateClonable, "setRangeDataStateClonable");
    range_sensor.def_property_readonly("minYawAngle", &cnoid::RangeSensor::minYawAngle);
    range_sensor.def_property_readonly("maxYawAngle", &cnoid::RangeSensor::maxYawAngle);
    range_sensor.def_property_readonly("yawRange", &cnoid::RangeSensor::yawRange);
    range_sensor.def_property_readonly("minPitchAngle", &cnoid::RangeSensor::minPitchAngle);
    range_sensor.def_property_readonly("maxPitchAngle", &cnoid::RangeSensor::maxPitchAngle);
    range_sensor.def_property_readonly("pitchRange", &cnoid::RangeSensor::pitchRange);

    py::class_<RangeCamera, RangeCameraPtr, Camera> range_camera(m, "RangeCamera");
    range_camera
        .def(py::init<>())
        .def("points", static_cast<const cnoid::RangeCamera::PointData& (cnoid::RangeCamera::*)() const>(&cnoid::RangeCamera::points), py::return_value_policy::reference_internal)
        .def("newPoints", &cnoid::RangeCamera::newPoints, py::return_value_policy::reference_internal)
        .def("depthImage", [](const RangeCamera &self) {
            typedef std::vector<Vector3f> PointData;
            const PointData &pts = self.constPoints();
            py::array_t<float> ret;
            ret.resize({(size_t)self.resolutionY(), (size_t)self.resolutionX()});
            py::buffer_info b = ret.request();
            float *ptr = static_cast<float *>(b.ptr);
            size_t cntr = 0;
            for(size_t y = 0; y < self.resolutionY(); y++) {
                for(size_t x = 0; x < self.resolutionX(); x++) {
                    *ptr++ = pts[cntr++].z();
                }
            }
            return ret; })
        //.def("sharedPoints", &cnoid::RangeCamera::sharedPoints)
        //.def("setPoints", &cnoid::RangeCamera::setPoints)
        .def("clearPoints", &cnoid::RangeCamera::clearPoints)
        .def("clearState", &cnoid::RangeCamera::clearState);
    // properties
    def_property_with_setter(range_camera, "maxDistance", &cnoid::RangeCamera::maxDistance, &cnoid::RangeCamera::setMaxDistance, "setMaxDistance");
    def_property_with_setter(range_camera, "minDistance", &cnoid::RangeCamera::minDistance, &cnoid::RangeCamera::setMinDistance, "setMinDistance");
    def_property_with_setter(range_camera, "isOrganized", &cnoid::RangeCamera::isOrganized, &cnoid::RangeCamera::setOrganized, "setOrganized");
    def_property_with_setter(range_camera, "isDense", &cnoid::RangeCamera::isDense, &cnoid::RangeCamera::setDense, "setDense");
    def_property_with_setter(range_camera, "detectionRate", &cnoid::RangeCamera::detectionRate, &cnoid::RangeCamera::setDetectionRate, "setDetectionRate");
    def_property_with_setter(range_camera, "errorDeviation", &cnoid::RangeCamera::errorDeviation, &cnoid::RangeCamera::setErrorDeviation, "setErrorDeviation");
    range_camera.def_property_readonly("numPoints", &cnoid::RangeCamera::numPoints);
    //// <<<< generated by gemini(IRSL)

    ////
    PyDeviceList<Device>(m, "DeviceList");
    PyDeviceList<ForceSensor>(m, "ForceSensorList");
}

}
